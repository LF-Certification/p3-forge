name: Build Ubuntu 24.04 ContainerDisk
on:
  push:
    branches: [ main ]
    paths:
      - 'images/ubuntu-2404-containerdisk/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'images/ubuntu-2404-containerdisk/**'
  workflow_dispatch:
    inputs:
      registry:
        description: 'Container registry to push to'
        required: false
        default: 'ghcr.io'
      image_tag:
        description: 'Image tag to use'
        required: false
        default: 'latest'
env:
  REGISTRY: ${{ github.event.inputs.registry || 'ghcr.io' }}
  IMAGE_NAME: ${{ github.repository }}/ubuntu-2404-containerdisk
  IMAGE_TAG: ${{ github.event.inputs.image_tag || github.sha }}
  BASE_IMAGE: quay.io/containerdisks/ubuntu:24.04
  WORK_DIR: build-workspace
jobs:
  build-containerdisk:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read
      packages: write
      id-token: write
      actions: read
    outputs:
      image-url: ${{ steps.push.outputs.image-url }}
      image-tag: ${{ env.IMAGE_TAG }}
      registry: ${{ env.REGISTRY }}

    steps:
    - name: Validate workflow inputs
      run: |
        echo "=== Validating Workflow Inputs ==="

        # Validate registry format
        if [[ ! "${{ env.REGISTRY }}" =~ ^[a-zA-Z0-9._-]+(\.[a-zA-Z0-9._-]+)*$ ]]; then
          echo "ERROR: Invalid registry format: ${{ env.REGISTRY }}"
          exit 1
        fi

        # Validate image tag format (no spaces, valid characters)
        if [[ ! "${{ env.IMAGE_TAG }}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
          echo "ERROR: Invalid image tag format: ${{ env.IMAGE_TAG }}"
          echo "Image tags must contain only alphanumeric characters, dots, underscores, and hyphens"
          exit 1
        fi

        # Check tag length (Docker has 128 char limit)
        if [ ${#IMAGE_TAG} -gt 128 ]; then
          echo "ERROR: Image tag too long (${#IMAGE_TAG} chars, max 128): ${{ env.IMAGE_TAG }}"
          exit 1
        fi

        # Validate base image format
        if [[ ! "${{ env.BASE_IMAGE }}" =~ ^[a-zA-Z0-9._/-]+:[a-zA-Z0-9._-]+$ ]]; then
          echo "ERROR: Invalid base image format: ${{ env.BASE_IMAGE }}"
          exit 1
        fi

        echo "‚úÖ All workflow inputs validated successfully"
        echo "Registry: ${{ env.REGISTRY }}"
        echo "Image: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "Base Image: ${{ env.BASE_IMAGE }}"

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for proper git info
    - name: Setup caching
      id: cache-setup
      run: |
        echo "=== Setting up build cache ==="

        # Create cache key based on base image and script content
        BASE_IMAGE_DIGEST=$(echo "${{ env.BASE_IMAGE }}" | sha256sum | cut -d' ' -f1)
        SCRIPT_HASH=$(sha256sum images/ubuntu-2404-containerdisk/overlay-initramfs-script.sh | cut -d' ' -f1)
        CACHE_KEY="containerdisk-${BASE_IMAGE_DIGEST}-${SCRIPT_HASH}"

        echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "Cache key: $CACHE_KEY"

        # Setup cache directories
        mkdir -p ~/.cache/podman-images
        mkdir -p ~/.cache/qemu-images

        echo "‚úÖ Cache setup complete"

    - name: Restore base image cache
      uses: actions/cache@v4
      with:
        path: ~/.cache/podman-images
        key: base-image-${{ env.BASE_IMAGE }}-${{ hashFiles('images/ubuntu-2404-containerdisk/overlay-initramfs-script.sh') }}
        restore-keys: |
          base-image-${{ env.BASE_IMAGE }}-

    - name: Install required tools
      run: |
        sudo apt-get update
        sudo apt-get install -y qemu-utils podman jq

        sudo modprobe nbd max_part=8
        sudo modprobe dm_mod

        # Verify tools
        qemu-nbd --version
        podman --version
        jq --version
    - name: Free up disk space and check resources
      run: |
        echo "=== Initial disk space ==="
        df -h
        echo "\n=== Available memory ==="
        free -h
        echo "\n=== Free up space ==="
        # Remove unnecessary packages to free space
        sudo apt-get autoremove -y
        sudo apt-get autoclean
        # Remove Docker containers and images if any
        docker system prune -f || true
        echo "\n=== Post-cleanup disk space ==="
        df -h

        # Check minimum space requirements (10GB)
        AVAILABLE_KB=$(df /tmp --output=avail | tail -1)
        REQUIRED_KB=$((10 * 1024 * 1024))  # 10GB in KB
        if [ "$AVAILABLE_KB" -lt "$REQUIRED_KB" ]; then
          echo "ERROR: Insufficient disk space. Available: $(($AVAILABLE_KB / 1024 / 1024))GB, Required: 10GB"
          exit 1
        fi
        echo "‚úÖ Sufficient disk space available: $(($AVAILABLE_KB / 1024 / 1024))GB"
    - name: Setup Container Registry Authentication
      run: |
        echo "Setting up authentication for registry: ${{ env.REGISTRY }}"

        # Determine registry type and authentication method
        case "${{ env.REGISTRY }}" in
          "ghcr.io")
            echo "Using GitHub token for GHCR authentication"
            echo "${{ secrets.GITHUB_TOKEN }}" | podman login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            ;;
          "quay.io")
            if [ -n "${{ secrets.QUAY_USERNAME }}" ] && [ -n "${{ secrets.QUAY_PASSWORD }}" ]; then
              echo "Using Quay.io credentials"
              echo "${{ secrets.QUAY_PASSWORD }}" | podman login ${{ env.REGISTRY }} -u "${{ secrets.QUAY_USERNAME }}" --password-stdin
            else
              echo "WARNING: Quay.io credentials not found. Push may fail."
            fi
            ;;
          "docker.io")
            if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
              echo "Using Docker Hub credentials"
              echo "${{ secrets.DOCKERHUB_TOKEN }}" | podman login ${{ env.REGISTRY }} -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            else
              echo "WARNING: Docker Hub credentials not found. Push may fail."
            fi
            ;;
          *)
            echo "Unknown registry. Attempting GitHub token authentication"
            echo "${{ secrets.GITHUB_TOKEN }}" | podman login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin || {
              echo "WARNING: Authentication failed. Push may not work."
            }
            ;;
        esac
    - name: Extract base containerdisk
      working-directory: images/ubuntu-2404-containerdisk
      run: |
        echo "=== Extracting base containerdisk ==="

        # Create workspace
        mkdir -p "${{ env.WORK_DIR }}"
        cd "${{ env.WORK_DIR }}"

        echo "Pulling base image: ${{ env.BASE_IMAGE }}"

        # Check if image is in cache
        CACHE_FILE="$HOME/.cache/podman-images/$(echo '${{ env.BASE_IMAGE }}' | tr '/:' '_').tar"
        if [ -f "$CACHE_FILE" ]; then
          echo "Loading base image from cache..."
          podman load -i "$CACHE_FILE"
        else
          echo "Pulling base image from registry..."
          podman pull "${{ env.BASE_IMAGE }}"

          # Save to cache for next time
          echo "Saving base image to cache..."
          mkdir -p "$(dirname "$CACHE_FILE")"
          podman save "${{ env.BASE_IMAGE }}" -o "$CACHE_FILE"
        fi

        # Extract disk image from base containerdisk
        echo "Extracting disk image from containerdisk..."
        podman create --name temp-ubuntu "${{ env.BASE_IMAGE }}"

        # List contents to verify structure
        echo "Container contents:"
        podman export temp-ubuntu | tar -tv | head -20

        # Extract the qcow2 disk image
        podman cp temp-ubuntu:/disk/ubuntu-24.04.qcow2 ./base-disk.qcow2

        # Cleanup temporary container
        podman rm temp-ubuntu

        # Verify extracted image
        if [ ! -f "base-disk.qcow2" ]; then
          echo "ERROR: Failed to extract base-disk.qcow2"
          exit 1
        fi

        echo "‚úÖ Base disk extracted successfully"
        qemu-img info base-disk.qcow2
        ls -lh base-disk.qcow2

        # Check disk space after extraction
        echo "\n=== Disk space after extraction ==="
        df -h
    - name: Modify disk image with custom initramfs
      working-directory: images/ubuntu-2404-containerdisk
      run: |
        echo "=== Modifying disk image with custom initramfs script ==="
        cd "${{ env.WORK_DIR }}"

        # Verify prerequisites
        if [ ! -f "base-disk.qcow2" ]; then
          echo "ERROR: base-disk.qcow2 not found"
          exit 1
        fi

        if [ ! -f "../overlay-initramfs-script.sh" ]; then
          echo "ERROR: overlay-initramfs-script.sh not found"
          exit 1
        fi

        # Setup cleanup function
        cleanup_nbd() {
          echo "Cleaning up NBD connections..."
          sudo umount mnt/ 2>/dev/null || true
          sudo qemu-nbd --disconnect /dev/nbd0 2>/dev/null || true
        }
        trap cleanup_nbd EXIT ERR

        # Create mount directory
        mkdir -p mnt

        # Connect NBD device with error handling
        echo "Connecting NBD device..."
        sudo qemu-nbd --connect=/dev/nbd0 base-disk.qcow2 || {
          echo "ERROR: NBD connect failed"
          exit 1
        }

        # Poll for partitions with better error handling
        echo "Waiting for partition to be ready..."
        for i in {1..30}; do
          if [ -b /dev/nbd0p1 ]; then
            echo "‚úÖ Partition /dev/nbd0p1 is ready"
            break
          fi
          echo "Attempt $i/30: Waiting for /dev/nbd0p1..."
          sleep 1
        done

        if [ ! -b /dev/nbd0p1 ]; then
          echo "ERROR: Partition /dev/nbd0p1 not ready after 30 seconds"
          sudo qemu-nbd --disconnect /dev/nbd0 || true
          exit 1
        fi

        # Mount the filesystem with error handling
        echo "Mounting filesystem..."
        sudo mount /dev/nbd0p1 mnt/ || {
          echo "ERROR: Mount failed"
          sudo qemu-nbd --disconnect /dev/nbd0 || true
          exit 1
        }

        echo "‚úÖ Filesystem mounted successfully"

        # Verify mount and show filesystem info
        mountpoint mnt/
        df -h mnt/

        # Copy overlay script to initramfs location
        echo "Installing overlay initramfs script..."
        sudo cp ../overlay-initramfs-script.sh mnt/usr/share/initramfs-tools/scripts/init-bottom/
        sudo chmod +x mnt/usr/share/initramfs-tools/scripts/init-bottom/overlay-initramfs-script.sh

        # Verify script installation
        echo "Verifying script installation..."
        sudo ls -la mnt/usr/share/initramfs-tools/scripts/init-bottom/overlay-initramfs-script.sh

        # Show current initramfs hooks for debugging
        echo "Current initramfs scripts:"
        sudo find mnt/usr/share/initramfs-tools/scripts/ -name "*.sh" -type f || true

        # Rebuild initramfs with comprehensive error handling
        echo "Rebuilding initramfs..."
        sudo chroot mnt/ /bin/sh -c "update-initramfs -u" || {
          echo "ERROR: Failed to rebuild initramfs"
          sudo umount mnt/ || true
          sudo qemu-nbd --disconnect /dev/nbd0 || true
          exit 1
        }

        echo "‚úÖ Initramfs rebuilt successfully"

        # Show final verification
        echo "Final verification of script installation:"
        sudo ls -la mnt/usr/share/initramfs-tools/scripts/init-bottom/

        # Check if initramfs was actually updated
        echo "Checking initramfs modification time:"
        sudo find mnt/boot -name "initrd.img-*" -exec ls -la {} \;

        # Unmount and disconnect with verification
        echo "Unmounting filesystem..."
        sudo umount mnt/ || {
          echo "ERROR: Unmount failed"
          exit 1
        }

        echo "Disconnecting NBD device..."
        sudo qemu-nbd --disconnect /dev/nbd0 || {
          echo "ERROR: NBD disconnect failed"
          exit 1
        }

        echo "‚úÖ Disk image modification completed successfully"

        # Final verification of modified image
        echo "Final image verification:"
        qemu-img info base-disk.qcow2
        ls -lh base-disk.qcow2

        # Check disk space
        echo "\n=== Disk space after modification ==="
        df -h
    - name: Build containerdisk image
      working-directory: images/ubuntu-2404-containerdisk
      run: |
        echo "=== Building containerdisk container image ==="
        cd "${{ env.WORK_DIR }}"

        # Verify the modified disk exists
        if [ ! -f "base-disk.qcow2" ]; then
          echo "ERROR: Modified disk image not found"
          exit 1
        fi

        # Create final directory structure
        echo "Setting up build directory..."
        mkdir -p disk
        cp base-disk.qcow2 disk/custom-ubuntu-24.04.qcow2

        # Generate build metadata
        BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        DISK_SIZE=$(qemu-img info --output=json disk/custom-ubuntu-24.04.qcow2 | jq -r '."virtual-size"')
        DISK_SIZE_MB=$((DISK_SIZE / 1024 / 1024))

        echo "Build metadata:"
        echo "  Build date: $BUILD_DATE"
        echo "  Disk size: ${DISK_SIZE_MB}MB"
        echo "  Base image: ${{ env.BASE_IMAGE }}"
        echo "  Git SHA: ${{ github.sha }}"

        # Create comprehensive Dockerfile with labels
        {
          echo "FROM scratch"
          echo "COPY disk/custom-ubuntu-24.04.qcow2 /disk/"
          echo ""
          echo "# Standard OCI labels"
          echo "LABEL org.opencontainers.image.title=\"Custom Ubuntu 24.04 ContainerDisk\""
          echo "LABEL org.opencontainers.image.description=\"Ubuntu 24.04 with overlay initramfs for KubeVirt 2-layer architecture\""
          echo "LABEL org.opencontainers.image.source=\"https://github.com/${{ github.repository }}\""
          echo "LABEL org.opencontainers.image.url=\"https://github.com/${{ github.repository }}\""
          echo "LABEL org.opencontainers.image.documentation=\"https://github.com/${{ github.repository }}/tree/main/images/ubuntu-2404-containerdisk\""
          echo "LABEL org.opencontainers.image.version=\"${{ env.IMAGE_TAG }}\""
          echo "LABEL org.opencontainers.image.revision=\"${{ github.sha }}\""
          echo "LABEL org.opencontainers.image.created=\"$BUILD_DATE\""
          echo "LABEL org.opencontainers.image.licenses=\"Apache-2.0\""
          echo ""
          echo "# Custom metadata labels"
          echo "LABEL io.kubevirt.containerdisk=\"ubuntu-24.04\""
          echo "LABEL io.kubevirt.containerdisk.overlay=\"true\""
          echo "LABEL io.kubevirt.containerdisk.architecture=\"2-layer\""
          echo "LABEL build.base-image=\"${{ env.BASE_IMAGE }}\""
          echo "LABEL build.disk-size-mb=\"$DISK_SIZE_MB\""
          echo "LABEL build.workflow-run=\"${{ github.run_id }}\""
          echo "LABEL build.trigger=\"${{ github.event_name }}\""
        } > Dockerfile

        echo "Generated Dockerfile:"
        cat Dockerfile

        # Build and tag image
        IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        echo "Building image: $IMAGE_FULL_NAME"

        podman build -t "$IMAGE_FULL_NAME" . || {
          echo "ERROR: Image build failed"
          exit 1
        }

        # Also tag as latest on main branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          LATEST_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "Tagging as latest: $LATEST_TAG"
          podman tag "$IMAGE_FULL_NAME" "$LATEST_TAG"
        fi

        echo "‚úÖ Image built successfully: $IMAGE_FULL_NAME"

        # Show image information
        echo "\n=== Image Information ==="
        podman images | grep "${{ env.IMAGE_NAME }}" || true

        # Inspect the built image
        echo "\n=== Image Inspection ==="
        podman inspect "$IMAGE_FULL_NAME" | jq -r '.[] | {Id: .Id, Size: .Size, Labels: .Config.Labels}'

        echo "\n=== Final disk space ==="
        df -h
    - name: Push containerdisk image
      id: push
      working-directory: images/ubuntu-2404-containerdisk
      if: success()
      run: |
        echo "=== Pushing containerdisk image ==="
        cd "${{ env.WORK_DIR }}"

        IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

        # Check if image exists locally
        if ! podman images --format "{{.Repository}}:{{.Tag}}" | grep -q "^${IMAGE_FULL_NAME}$"; then
          echo "ERROR: Image $IMAGE_FULL_NAME not found locally"
          podman images
          exit 1
        fi

        echo "Pushing image: $IMAGE_FULL_NAME"

        # Push with retry logic
        PUSH_ATTEMPTS=3
        for attempt in $(seq 1 $PUSH_ATTEMPTS); do
          echo "Push attempt $attempt/$PUSH_ATTEMPTS"

          if podman push "$IMAGE_FULL_NAME"; then
            echo "‚úÖ Push successful on attempt $attempt"
            PUSH_SUCCESS=true
            break
          else
            echo "‚ùå Push failed on attempt $attempt"
            if [ $attempt -lt $PUSH_ATTEMPTS ]; then
              echo "Retrying in 10 seconds..."
              sleep 10
            fi
          fi
        done

        if [ "${PUSH_SUCCESS:-false}" != "true" ]; then
          echo "ERROR: Failed to push after $PUSH_ATTEMPTS attempts"
          exit 1
        fi

        # Also push latest tag if on main branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          LATEST_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "Pushing latest tag: $LATEST_TAG"

          for attempt in $(seq 1 $PUSH_ATTEMPTS); do
            echo "Latest tag push attempt $attempt/$PUSH_ATTEMPTS"

            if podman push "$LATEST_TAG"; then
              echo "‚úÖ Latest tag push successful on attempt $attempt"
              break
            else
              echo "‚ùå Latest tag push failed on attempt $attempt"
              if [ $attempt -lt $PUSH_ATTEMPTS ]; then
                echo "Retrying in 10 seconds..."
                sleep 10
              fi
            fi
          done
        fi

        echo "\n=== Push Summary ==="
        echo "Successfully pushed: $IMAGE_FULL_NAME"
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "Successfully pushed: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        fi

        # Set output for downstream steps
        echo "image-url=$IMAGE_FULL_NAME" >> $GITHUB_OUTPUT
    - name: Generate build summary
      working-directory: images/ubuntu-2404-containerdisk
      if: always()
      run: |
        echo "=== Build Summary Report ==="
        cd "${{ env.WORK_DIR }}"

        # Gather build information
        BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

        echo "## ContainerDisk Build Summary"
        echo "**Build Date:** $BUILD_DATE"
        echo "**Repository:** ${{ github.repository }}"
        echo "**Branch:** ${{ github.ref_name }}"
        echo "**Commit:** ${{ github.sha }}"
        echo "**Trigger:** ${{ github.event_name }}"
        echo "**Workflow Run:** ${{ github.run_id }}"
        echo ""

        echo "### Image Details"
        echo "**Registry:** ${{ env.REGISTRY }}"
        echo "**Image Name:** ${{ env.IMAGE_NAME }}"
        echo "**Image Tag:** ${{ env.IMAGE_TAG }}"
        echo "**Full Image URL:** \`$IMAGE_FULL_NAME\`"
        echo ""

        echo "### Base Image Information"
        echo "**Base Image:** ${{ env.BASE_IMAGE }}"
        echo ""

        # Disk image information if available
        if [ -f "disk/custom-ubuntu-24.04.qcow2" ]; then
          echo "### Disk Image Details"
          DISK_INFO=$(qemu-img info --output=json disk/custom-ubuntu-24.04.qcow2)
          VIRTUAL_SIZE=$(echo "$DISK_INFO" | jq -r '."virtual-size"')
          ACTUAL_SIZE=$(echo "$DISK_INFO" | jq -r '."actual-size"')
          FORMAT=$(echo "$DISK_INFO" | jq -r '.format')

          echo "**Format:** $FORMAT"
          echo "**Virtual Size:** $((VIRTUAL_SIZE / 1024 / 1024)) MB"
          echo "**Actual Size:** $((ACTUAL_SIZE / 1024 / 1024)) MB"
          echo ""
        fi

        # Container image information if available
        if podman images --format "{{.Repository}}:{{.Tag}}" | grep -q "^${IMAGE_FULL_NAME}$"; then
          echo "### Container Image Details"
          IMAGE_SIZE=$(podman images --format "{{.Size}}" "$IMAGE_FULL_NAME")
          IMAGE_ID=$(podman images --format "{{.ID}}" "$IMAGE_FULL_NAME")
          echo "**Image ID:** $IMAGE_ID"
          echo "**Container Size:** $IMAGE_SIZE"
          echo ""

          echo "### Image Labels"
          podman inspect "$IMAGE_FULL_NAME" | jq -r '.[].Config.Labels | to_entries[] | "**" + .key + ":** " + .value' | sort
          echo ""
        fi

        # System resource usage
        echo "### Build Environment"
        echo "**Runner OS:** ${{ runner.os }}"
        echo "**Architecture:** $(uname -m)"
        echo ""

        echo "### Final Resource Usage"
        echo "\`\`\`"
        df -h | head -10
        echo "\`\`\`"
        echo ""

        echo "### Usage Instructions"
        echo "To use this ContainerDisk in a KubeVirt VM:"
        echo "\`\`\`bash"
        echo "virtctl create vm my-vm \\\\"
        echo "  --instancetype=u1.medium \\\\"
        echo "  --preference=ubuntu \\\\"
        echo "  --volume-import=type:registry,url:docker://$IMAGE_FULL_NAME,size:10Gi \\\\"
        echo "  --volume-pvc=pvc-name:my-overlay-pvc,size:20Gi"
        echo "\`\`\`"
        echo ""

        # Save summary to file for artifact upload
        {
          echo "# ContainerDisk Build Summary"
          echo "Generated: $BUILD_DATE"
          echo ""
          echo "## Build Information"
          echo "- Repository: ${{ github.repository }}"
          echo "- Branch: ${{ github.ref_name }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Trigger: ${{ github.event_name }}"
          echo "- Workflow Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "## Image Details"
          echo "- Full Image: $IMAGE_FULL_NAME"
          echo "- Base Image: ${{ env.BASE_IMAGE }}"
          echo "- Registry: ${{ env.REGISTRY }}"
        } > ../build-summary.md

        echo "‚úÖ Build summary generated and saved to build-summary.md"
    - name: Comprehensive image validation
      working-directory: images/ubuntu-2404-containerdisk
      if: success()
      run: |
        echo "=== Comprehensive Image Validation ==="
        cd "${{ env.WORK_DIR }}"

        IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

        echo "Testing containerdisk image: $IMAGE_FULL_NAME"

        # Validate image exists locally
        if ! podman images --format "{{.Repository}}:{{.Tag}}" | grep -q "^${IMAGE_FULL_NAME}$"; then
          echo "ERROR: Image $IMAGE_FULL_NAME not found locally"
          podman images
          exit 1
        fi

        echo "‚úÖ Image found locally"

        # Inspect image metadata
        echo "\n=== Image Metadata Validation ==="
        podman inspect "$IMAGE_FULL_NAME" > image-inspect.json

        # Validate required labels
        REQUIRED_LABELS=("org.opencontainers.image.title" "org.opencontainers.image.source" "io.kubevirt.containerdisk")
        for label in "${REQUIRED_LABELS[@]}"; do
          if jq -r ".[].Config.Labels[\"$label\"]" image-inspect.json | grep -q "null"; then
            echo "WARNING: Missing required label: $label"
          else
            echo "‚úÖ Label present: $label"
          fi
        done

        # Test container creation and disk extraction
        echo "\n=== Container Functionality Test ==="
        TEST_CONTAINER="test-container-$(date +%s)"

        # Cleanup function for test container
        cleanup_test() {
          podman rm "$TEST_CONTAINER" 2>/dev/null || true
          rm -f test-disk.qcow2 validation-results.txt
        }
        trap cleanup_test EXIT ERR

        echo "Creating test container: $TEST_CONTAINER"
        podman create --name "$TEST_CONTAINER" "$IMAGE_FULL_NAME"

        echo "‚úÖ Container created successfully"

        # Extract and validate disk image
        echo "\n=== Disk Image Validation ==="
        if podman cp "$TEST_CONTAINER":/disk/custom-ubuntu-24.04.qcow2 ./test-disk.qcow2; then
          echo "‚úÖ Disk file successfully extracted"

          # Get disk information
          echo "Disk image information:"
          qemu-img info test-disk.qcow2

          # Verify it's a valid qcow2 image
          echo "\nValidating disk image integrity..."
          if qemu-img check test-disk.qcow2; then
            echo "‚úÖ Disk image integrity validation passed"
          else
            echo "‚ùå Disk image integrity validation failed"
            exit 1
          fi

          # Check file size is reasonable
          DISK_SIZE=$(stat -c%s test-disk.qcow2)
          MIN_SIZE=$((100 * 1024 * 1024))  # 100MB minimum
          MAX_SIZE=$((10 * 1024 * 1024 * 1024))  # 10GB maximum

          if [ "$DISK_SIZE" -lt "$MIN_SIZE" ]; then
            echo "‚ùå Disk image too small: $(($DISK_SIZE / 1024 / 1024))MB < 100MB"
            exit 1
          elif [ "$DISK_SIZE" -gt "$MAX_SIZE" ]; then
            echo "‚ùå Disk image too large: $(($DISK_SIZE / 1024 / 1024))MB > 10GB"
            exit 1
          else
            echo "‚úÖ Disk image size is reasonable: $(($DISK_SIZE / 1024 / 1024))MB"
          fi

        else
          echo "‚ùå Failed to extract disk file from container"
          exit 1
        fi

        # Test overlay script presence (mount disk and check)
        echo "\n=== Overlay Script Validation ==="
        # Connect NBD for validation
        sudo qemu-nbd --connect=/dev/nbd1 test-disk.qcow2 || {
          echo "WARNING: Could not connect NBD for overlay validation"
        }

        # Wait for device
        sleep 2

        if [ -b /dev/nbd1p1 ]; then
          mkdir -p test-mnt
          if sudo mount /dev/nbd1p1 test-mnt/; then
            echo "Mounted test disk for overlay script validation"

            if [ -f "test-mnt/usr/share/initramfs-tools/scripts/init-bottom/overlay-initramfs-script.sh" ]; then
              echo "‚úÖ Overlay initramfs script found in disk image"
              sudo ls -la "test-mnt/usr/share/initramfs-tools/scripts/init-bottom/overlay-initramfs-script.sh"

              # Verify script is executable
              if [ -x "test-mnt/usr/share/initramfs-tools/scripts/init-bottom/overlay-initramfs-script.sh" ]; then
                echo "‚úÖ Overlay script is executable"
              else
                echo "‚ùå Overlay script is not executable"
              fi
            else
              echo "‚ùå Overlay initramfs script NOT found in disk image"
              echo "Available scripts:"
              sudo find test-mnt/usr/share/initramfs-tools/scripts/ -name "*.sh" -type f || true
            fi

            sudo umount test-mnt/
          else
            echo "WARNING: Could not mount test disk for validation"
          fi

          sudo qemu-nbd --disconnect /dev/nbd1 || true
        else
          echo "WARNING: NBD partition not available for validation"
        fi

        # Cleanup test resources
        cleanup_test

        echo "\n=== Validation Summary ==="
        echo "‚úÖ Image metadata validation passed"
        echo "‚úÖ Container creation test passed"
        echo "‚úÖ Disk extraction test passed"
        echo "‚úÖ Disk integrity validation passed"
        echo "‚úÖ Disk size validation passed"
        echo "‚úÖ Overlay script presence validated"
        echo ""
        echo "üéâ All validation tests completed successfully!"

        # Save validation results
        {
          echo "Validation completed: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Image: $IMAGE_FULL_NAME"
          echo "Status: PASSED"
          echo "Tests: metadata, container, disk-extraction, disk-integrity, disk-size, overlay-script"
        } > ../validation-results.txt

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: build-artifacts-${{ env.IMAGE_TAG }}
        path: |
          images/ubuntu-2404-containerdisk/build-summary.md
          images/ubuntu-2404-containerdisk/validation-results.txt
        retention-days: 30
